# 支持RISC-V架构的，基于FPGA的可配置嵌入式系统的硬件实时事件管理 ？？

摘要——任务上下文切换，统一的事件管理，同步和通信机制是每个实时操作系统的主要问题。对实时系统而言，另一个开销因子？？是处理器执行外部异步中断的时间。这篇论文的主要目的是使用RISC-V指令集和Verilog硬件描述语言来描述，实现，并且验证抢先式调度器模块当作硬件加速实时系统的一部分。这个新的架构包含用于静态/动态调度任务、实时事件管理的硬件结构，并且定义了关联中断到任务的方法。为了达成这个目的，定义易于移植到其他实现（MIPS协处理器、ARM或者RISC-V）的CPU模块是很有必要的。

关键词——流水线处理器，现场可编程门阵列，架构，操作系统，调度。

# 一 介绍

现今，嵌入式系统是实现物联网和工业4.0项目的理想平台。用于汽车领域、机器人或工业自动化的各种实时系统（RTOS），必须确保在规定时间内给出响应。对这些系统而言，用于任务上下文切换和RTOS抖动所需的时间是处理非周期性外部事件的关键参数。在中央处理器（CPU）中，上下文指的是寄存器中的数据和在特定时间运动中的程序计数器。在现实中，安全至上的系统使用密集的，实现复杂机制来隔离关键与非关键器件的ROTS。把操作系统，或其中一些组建移动到硬件的目的，是减少由异步事件引入的非确定性源。因为某些原因，一个解决方案需要在它的状态与平常工作模式不同的时候由系统提供可预测并且精准的响应，比如服务模式。然而，一个RTOS对每个执行的任务有明指定的死线，来支持有精确时间要求的应用。

为了设计并实现一个实时时间管理系统，本论文提出了基于RISC-V架构的nMPRA概念（Multi Pipleline Register Architecture，多流水线寄存器架构，n代表有多少级）。这个硬件加速处理器的主要特征由单时钟周期，最差情形对用于外部内存访问[1]的特殊指令三时钟周期的上下文切换行动所定义。这个实时事件处理模块的实现提供了极强的性能，表现在响应时间和任务上下文切换减少的时间；这个架构适合于实时小规模应用，因为multiply……？？所需的资源消耗。本文提出的处理器是确定性的硬件，因为整合的抢先式调度器和ZScale–RISC-V架构。在这个项目中，由伯克利开源的三级流水线VScale的Verilog实现需要被用到以实现nMPRA和nHSE（Hardware Scheduler Engine for n tasks，对n项任务的硬件调度引擎）。此外，RISC-V指令集和Virtex-7 VC707开发套件需要被用于综合和FPGA实现。这个实验性项目意在实现，测试并验证作为提出为处理器[2][3]一部分的动态调度模组，使用RISC-V指令集还有Z-Scale三级流水线架构的实现？？？语序。实现将在FPGA上以各种配置验证，considering？？n - 任务数量，i - 中断数量，m - 互斥锁数量，还有s - 通信时间数量。RTOS特有的功能，比如任务调度器，同步和任务内通信机制，在实时系统（RTS）中占据特殊角色。这些机制的硬件实现的缺失是在这个领域中研究的挑战。因此，FPGA电路[4]可以为了提供低响应时间，最小的抖动和低能耗[5][6]被用于设计和测试硬件实现的微处理器。本文提出的处理器是确定性的硬件，因为整合的抢先式调度器和ZScale–RISC-V架构（原文的确又重复了一遍——译者注）。

respect？？我们相信这篇论文做出了以下几点贡献：

- 基于现有科技，提出的时间爱你处理模块概念已经用RISC-V指令集实现。
- 为了验证提出的用于同意事件管理的抢先式调度器模组和Verilog的VScale实现我们做了测试。
- Obtain？？使用于广泛不同配置（4，8和16级资源multi？？）的FPGA芯片上的逻辑组建数量和隐式实时时间处理模块（中断、互斥锁和消息事件的数量）与RISC-V架构coreespondence？？

本论文结构如下：第一小节包含简短的介绍，第二小节描述了实时嵌入式系统领域中相似的论文。第三小节展示了基于RISC-V架构的nMPRA处理器操作的概念和理论，第四小节描述了上一小节中展示的理论元件在验证中得到的实用结果。在第五小节作者展示了本论文最后的结论。

# 二 相关工作

本小节分析并比较了在实时调度领域提出的几个CPU实现和项目。突出了被分析架构关于调度器的理论和实用方面以及实时特性。最有代表性的用硬件实现功能的CPU和RTOS研究项目的调度器实现[7]，流水线assembly？？和实现类型。

在[8]提出的处理器核心由两个五级流水线组成。第一个专注于单个硬实时线程（hard read-time thread, HRT），第二个流水线专注于非HRT（non-HART, NHRT）。在四核版本中，每个核由四个硬件插槽slot？？组成。因此，每个核可以同时执行一个HRT和三个NHRT。HRT被赋予最高优先级，由实时调度器将其从核心中与另外的NHRT隔离。线程优先级固定，调度方案选择了轮转调度法。

Kuacharoen，Shalan和Mooney[9]提到商用软件调度器会有很大的开销。当时钟频率是100KHz，仅有64项任务时，开销需要几乎要占据46%的CPU使用量。把调度操作用硬件实现带来的时间收益可以用来执行系统里一到两个有用的任务。用于上下文切换的时间爱你是内核[10]的固有边界，不依赖于调度算法或任务集结构。设Q为系统的时间片数量tick？？，σ是某周期性任务的最差执行时间（WCET），引入的开销记为 $U_t$占用率因子，可以由以下关系得到：
$$
U_t = \sigma / Q
$$
考虑抢先性带来的调度操作效果时，可以把$U_t$加到对应周期性任务集的使用因子中。

通常，抢先性RTOS有优先级反转场景，当高优先级任务被地优先级任务的一部中断挂起时。把任务和中断事件在同意地址空间中组织ordering？？可以避免这种缺点。尽管它消除了因为调度操作的过度控制，但协处理器-处理器架构不能消除以下几种过度控制：

- 总线仲裁开销（对向连接到同意总线的不同设备通信而言，例如DMA）。
- 有效数据在CPU总线中的传输时间。
- 中断处理时间（对主处理器出发了中断机制的事件而言）。
- 保存、恢复任务上下文的时间爱你，操作仍然在传统处理器模式下进行。

对于从先进上下文管理机制受益的商业处理器架构，我们提到了英飞凌的TriCore 1.3.1[12]和英特尔的80960[13]。TriCore架构有效地在硬件管理并维护了任务上下文。上下文切换发生在一个事件或指令让程序执行发生中断（break，不是interrupt），在当前上下文中CPU需要在继续程序之前处理这个事件。TriCore架构使用32个寄存器，16个放地址，16个放数据。寄存器管理机制可以仅部分地自动把寄存器存储在栈上。在32个寄存器中，只有16个会被存在上下文保存区域中（Context Save Area，CSA）。为了存储另外16个寄存器，用户必须手动开始这项操作。尽管这个架构已经为高效上下文切换做出了优化，但最大的障碍是把上下文存在栈上的时间。因此，如果想要完整保存执行栈的上下文，我们需要执行手动保存一般通用寄存器的一段时间。

在I960处理器家族，用户从一组自动映射到一块叫栈帧的内存区域，由帧指针（Frame Pointer，FP）指出的局部寄存器中受益。g15寄存器被保留来保存当前FP，也就是在当前（最高的）栈帧中第一个字节的地址。这个架构有一个用于有限数量任务的环形帧缓冲区。即使它是一个相关的架构，I980仍然有两处缺陷。上下文保存引入了栈内存事务，而它比处理器内部的寄存器要慢。对于RTS所需的确定性，这个架构可以消除那些内存帧与人物栈帧的机械关联来解决。

# 三 基于RISC-V的硬件加速处理器的概念和理论

本论文覆盖的问题包括用于被提出实现的架构、硬件调度器寄存器到nMPRA概念的整合[14]，资源复制、流水线级数，还有同步与通信机制。并且，也考虑了基于优先级的抢先调度算法硬件的整合。流水线的主要组成如下：

- 取指/解码 - 执行（IF/IDEX）和解码 - 执行/访存 - 写回（IDEX/MEMWB）流水线寄存器。
- 拥有程序计数器（PC）家在模块的取指阶段和用PC寻址I$指令存储器（作为替代的，ALU、CSR输出的EPC和EVEC输出可以被当作指令使用）。此外，指令存储器和简单的加法器（+4）可以被用于给PC寄存器递增。
- 指令解码和执行阶段包括立即数生成器、寄存器堆和前推多路复用器的实现、A和B多路复用器、ALU组合逻辑单元、数据存储控制单元、CSR模块多路复用器和来自寄存器堆的数据或来自指令的立即数、条件跳转模块，和控制单元。
- 接触内存和写回数据的阶段包括以下几个模块：数据存储器，包括实时调度器寄存器的CSR模块、充电？？模块、用于PC-IDEX/MEMWB的4位加法器和选择哪个数据来写回到寄存器堆的多路复用器。

这个项目在xc7vx485tffg1761-2上被综合，实现了nMPRA+nHSE概念，n=1, 2, 4, 8, 16, 32，可变数量的中断（i = 1÷ 32）和互斥锁（m = 1 ÷ 32），以及可变数量的信号（s = 1 ÷ 32）（的确是一除以三十二——译者注）。

这篇论文从始至终，使用信号（signal，s）命名任务间被实时调度器验证和处理的同步和事件。nHSE和nMPRA块必须用Verilog HDL实现来确保不同n，i，m和s参数的配置能被简单地综合。让资源翻倍的决定将在分析了VScale实现的正确性、三个流水线阶段，和RISC-V指令集[16][17]后做出。基本思想是除去数据、指令存储器外数据通路上的每一个存储单元都会翻n倍，它的输出也会由多路复用器从n变成1。这样的设计师为了让被提出的功能性可以被测试。

如图1，Z-Scale是被nMPRA选中的架构，而Vscale（原文S就没大写——译者注）是被选中的实现。这个架构在Xilinx的Virtex-7 FPGA和VC707开发套件上被实现、验证。

nMPRA概念极高速的上下文切换是由把要执行的任务活跃上下文在硬件上重映射实现的。对于FPGA实现的电力消耗，如果所有任务都不活跃，和sCPUi相关的流水线会被硬件调度控制寄存器放进睡眠模式。图1中的这个架构被设计成有三级流水线，分别是：

- 用于提取指令（FETCH）的阶段和IF/IDEX流水线寄存器。
- 解码和执行指令的阶段和紧随其后的IDEX/MEMWB流水线寄存器。
- 访问存储器，CSR和写回寄存器堆的阶段。

接下来描述一些ZScale - nMPRA数据通路实现的信号。PC_src_sel（select PC source）信号被控制单元（图2）设置，用于选择哪个PC_IF_REG（新PC）被加载为下一个值。imm_type信号根据指令组选择立即数类型。alu_op的隐含值是`ALU_OP_ADD，用来选择ALU模块需要执行的操作，add_or_sub变量算则是加法还是减法。考虑到funct7[5]是inst_DX（在控制单元的32比特输入），用来更新这个值的Verilog代码如下：

```verilog
assign add_or_sub = ((opcode == `RV32_OP) && (funct7[5])) ? `ALU_OP_SUB : `ALU_OP_ADD;
```

dmem_en信号表明访问数据存储器（读或写），dmem_en_unkilled信号表明两种访存指令的类型（LOAD或STORE）。dmem_wen（数据存储器写使能）信号对数据存储器设置写操作，输出变量dmem_size定义数据存储器的大小。输出变量csr_imm_sel（CSR立即数选择）为CSR模块选择立即数直接来源于指令（=0），或是旁路数据，或是寄存器堆（=1）。输出数据wr_reg_WB（在写回阶段的写寄存器）表明MEMWB阶段将会写回到寄存器堆。局部寄存器dmem_en_WB表示MEMWB阶段用于数据存储器是否有效（LOAD或STORE）的控制信号。在指令解码阶段，wr_reg_DX变量表明对被解码的指令，在MEMWB阶段可能会发生写回到寄存器。输出变量reg_to_wr_WB存储了MEMWB阶段将要被写入寄存器的地址。

如表格1所示，nMPRA在硬件中实现了互斥锁，并且每个grMutexi全局寄存器包含一位来存储互斥锁的状态，以及m-1位表示所有者的sCPUi标识符。互斥锁寄存器堆（Mutex Register File，MRF）可以被任何sCPU访问到，所以它们是所有sCPUi的共享资源。因此，每个sCPUi在每次一个被阻塞的互斥锁被释放时（来自MRF的互斥锁i位）会生成一个MutexEvi事件（crEVi[5]）。一个互斥锁的阻塞和释放操作在单周期完成，是原子操作。实时时间爱你处理模块使用一定数量的grSRFi全局寄存器来组合信号寄存器堆（Signals Register FIle，SRF）。

为了实现任务间通信机制（表格2），每个grSRFi（全局寄存器信号寄存器堆i）使用一个比特来存储事件状态（事件i），snj个比特来存储事件ID，它们的发送方（sIDnj-1÷s_ID0）和接收方（d_IDnj-1÷d_ID0），还有k位来存储信息（Mess k-1÷Mess 0）。

硬件块，在抢先式调度器模块实现，自动生成第一个空闲事件的地址（从0开始）还有是否所有事件都在活跃中（设为1）。因为grSRFi寄存器的内容寻址处理器（CAM）查找在硬件实现，跳转到信息事件（被命名为SynEvi的crEVi[6]位）被赋予的自陷cell？？在两个时钟周期内可以完成。硬件加速RTOS的重要一点是sCPUi计时器（例如，以监管者寄存器的形式等）和为了取得内部信息的debug接口的Verilog实现。基于ZScale，？？横线？？nMPRA规范的VScale资源重复，包括扩展和实时事件处理模块的Verilog代码以Verilog HDL设计？？。

基于RISC-V架构的nMPRA实现还包括以下数据通路信号，一句它们影响的执行活性分组。stall_IF信号保留了取指阶段的数据，它被imem_wait，redirect，stall_DX和例外信号的状态所直接影响。线类型的输出信号kill_IF由prev_killed_DX_reg和prev_killed_DX_reg双稳态传播，阻塞了PC_IF_reg[31:0]寄存器的内容。CSR地址管理使用CSR地址位来编码默认访问特权级。

这简化了硬件的错误检查并提供了更大的CSR空间，但限制了CSR在地址空间的映射。这个实现可以让高特权级访问其他低特权级CSR的寄存器，为了截听这些访问。这项改动应该对低特权级软件透明。WB_SRC_SEL_WIDTH宽的wb_src_sel_WB寄存器存储了要在WB阶段更新寄存器值时选哪个来源。wb_src_sel_DX变量在译码/执行阶段选择写回阶段数据来源。一位信号stall_WB从写回阶段停止流水线，dmem_wait信号表明数据寄存器还没有执行读或写操作。对于分支操作的指令和逻辑，branch_taken信号表明发生分支操作。因此，branch_taken_unkilled寄存器表明分支指令的解密还有ALU给出的cmp_true。在这样的上下文中，输入线cmp_true验证了分支的条件为真。局部变量jal表示执行JAL指令，而jal_unkilled为同样的指令设置解码？？jalr变量表明执行jalr指令（原文就大写JAL小写jalr——译者注），而局部便来那个replay_IF开启kill_IF，关闭ex_IF,并且决定PC_src_sel = `PC_REPLAY。局部illegal_instruction变量表明不存在的指令，而illegal_csr_access输入信号表明对CSR的非法访问。load_use变量标志了在写回阶段是否有LOAD指令造成的冒险，load_in_WB信号验证了在写回阶段有load操作。

# 四 基于RISC-V概念的实用结果

这个硬件加速处理器架构是由图1中展示的RISC-V（Z-scale）的所有寄存器翻倍实现的。所有存储器元件被乘以了32，所以n = 32。在硬件实时事件处理块中的寄存器被影射到了CSR区域，有以下地址：0x200-0x2BF，0xA00-0xAFF和0xE00-0xEFF。

内部调度器寄存器的初始化是由访问那些保留区域的指令完成的。表格3列出了一个配置事件处理单元内部寄存器的示例汇编程序。接下来，我们将展示在不同时间间隔下sCPU0，sCPU1和sCPU2开启计时事件的RISC-V处理器操作。INT0、INT1、INT2、INT3中断被单独分配给半处理器sCPU7，sCPU5，sCPU7，sCPU4（原文就是两个7——译者注）。

中断优先级又被分配给的sCPUi给出。sCPU0中断历程会禁止中断（sCPU0是最高优先级，sCPU31是最低优先级）。图3展示了两个同时发生的中断，第一个有最高优先级（sCPU5）的被处理了，uiSelectCPU[4:0] = 5。中断处理带来的延迟最多有两个时钟周期。

一个中断只能关联到一项任务[2]，而一项任务可以关联过呢该多中断（甚至全部）。没有使用约束，这是在FPGA实现层级自动运行？？的。在开启实时事件处理单元之后，在硬件中实现的寄存器通过wAddress和wRdData/wWrData信号访问。bIdleCPU信号在整个系统进入睡眠模式时被用到。这种情况发生于所有sCPUi处在睡眠模式中。调度器在验证并关联一个活跃中断到特定sCPUi后会退出这个模式。图4展示了在高优先级中断失活之后，低优先级中断被处理了（uiSelectCPU[4:0] = 7）[18]。当INT3（最高优先级）被激活后，sCPU4（uiSelectCPU[4:0]
= 4）被选择了。还能观察到只要有中断活跃中，计时器0、1和2的事件就不会被处理，中断事件有最高的优先级。

图5展示了没有中断时的计时事件处理。计时事件的发生依赖于以下寄存器定义的重加载的数据：mrTEV0 = 0x3f，mrTEV1 = 0x1f还有mrTEV2 = 0xf。计时计数器（uiTCounter）递减直到它们的值变成0。然后，它们生成一个计时事件（crEVi[0] = 1），触发生成了那个事件的sCPUi。当计时事件被禁用（crTR1[0] = 0），uiSelectCPU[4:0]信号在计时信号发生在sCPU1时不再是1。对于事件的选择可以通过执行一个简单的汇编指令完成[2]。为了在FPGA上测试并验证，RISC-V（Z Scale）架构被扩展，开发了新的硬件调度器概念相关的软件应用

访问不存在CSR的尝试会触发非法指令异常。而且，访问CSR时没有足够的特权、写一个只读寄存器会生成代表非法指令执行的异常[19]

每个sCPUi执行在开始标签和jrx29指令之间的代码。比如，sCPU0上运行的代码位于start0:和jrx29之间。sCPU3上运行的代码位于start3: lui x5, 0 //x5 = 0和jrx29 //go to start3之间。对于每个sCPUi的起始指令地址是，sCPU0在200h，sCPU1在300h，最后的sCPU31在2100h。nMPRA处理器的想以后那个时间可以在异步外部事件发生时模拟和测量，还有用于上下文切换的时间也可以被确定。因此，一段汇编代码已经被实现，用于编程nHSE寄存器来触发不同时间时间，响应外部事件，比如异步中断[20][21]。激活每个sCPUi的时间爱你可以用执行简单的nHSE指令来达成。中断可以是各种各样的，并且不需要专门的控制器，优先级和关联的sCPUi一致。

为了实现延时，分别为每个sCPUi实现了一段循环。当执行完这段循环后，csrrw 780, x28指令通过Virtex-7开发套件的LED灯显示赋予CPU的号码来表示退出循环，并且跳转回x29寄存器中的起始地址。因此，当一个sCPUi活跃时，它的ID可以通过LED显示的二进制组合来看到。

最高优先级的半处理器，sCPU0,有复数段代码因为它要用于配置实时事件处理单元。因此，它向cr0MSTOP寄存器写入0xF00000FF，开启12个sCPUi的。

sCPU0加载寄存器mrTEV0 = 0x0060003F, mrTEV1 = 0x0050001F, mrTEV2 = 0x0040000F, mrTEV31 = 0x00300007为了在半处理器0、1、2和31上生成间隔不同的计时器事件；它还编程让grINT_ID0 = 0x00000007, grINT_ID1 = 00000005, grINT_ID2 = 00000007, grINT_ID3 = 00000004把四个已经存在的中断赋给特定的sCPUi。注意中断0和中断2被赋给了同样的sCPU7半处理器，所以grNrINT寄存器将存储最高优先级sCPUi的地址。半处理器0、1、2和31的计时事件：crTR0 = 0x00000001, crTR1 = 0x00000001, crTR2 = 0x00000001和 crTR31 = 0x00000001也被开启了。

对于对被提出架构的响应时间测试，最高优先级的任务threat？？一个连接到Virtex-7测试按钮的外部中断。在执行完初始化硬件调度器需要的指令序列之后，最高优先级的任务等待被crTRi寄存器验证的事件（在这里，是外部中断）。当姐在Virtex-7套件上的信号改变了状态（图6.a的时刻1），外部中断被生成，硬件寄存器将会转去执行那个有最高优先级的任务。这将设置在时刻2中展示的第二个测试信号。

图6.a展示了基于一个33MHz的RISC-V的硬件RTOS架构的测试结果。时刻1表现了外部事件激活，时刻2表示了抢先式调度器激活了最高优先级（68ns）的任务（sCPU0）。因此，通过重复每原来流水线数据通路上的存储器资源，我们得到了图1。这张图展示了每个流水线寄存器都被复制了，上下文切换操作通过uiSelectCPU（select）信号完成。寄存器堆也被翻倍了。5位的uiSelectCPU信号通过在CSR单元中实现的硬件调度器生成[22]。图6.b展示了使用µC/OS-II实时操作系统和25MHz的五级流水线32位RISC ARM966E-S微控制器时对事件同步机制的响应时间$D_t = 38.36µs$。图6.c和图6.d展示了通过使用RTX RTOS(Dt = 10.48µs)和FreeRTOS (Dt = 91.45µs) 运行于STM32F429微控制器和事件同步得到的结果。响应时间可以通过同步事件发生到为处理器管脚状态改变的时间观察到。在外部中断处理的上下文中，抖动依赖于CPU当前执行的指令，嵌套向量化控制器（NVIC），中断服务例程（ISR）长度，中断优先级和Cortex-M4硬件架构（通常是12周期的延迟，保存同于寄存器R0-R3，R12，Link寄存器，PC和程序状态寄存器）。

图7展示了用来实现有抢先式动态调度器（n = 32 sCPUs）的被提出架构的逻辑单元分布。FPGA实现合并了用于时间相关事件、外部中断和同步以及通信事件的硬件处理模块。在此情境中，HW-RTOS提供sCPUi管理、互斥锁、消息、硬件计时器和异步中断。在实现过程中，对不同配置的nMPRA架构开展了测试。分析给出了FPGA电路中资源占用百分数和对不同翻倍数量n，i，m，s = 1, 2, 4, 8, 16和32。的处理频率。结果在表格4中展示。

为了验证本文提出的理论，展示了任务上下文切换的实时性验证，FPGA实现，和FPGA芯片上逻辑元件的分布。

# 五 结论

这个展示的硬件调度器实现的特点就是对事件的反应快，因为被提出架构用支持新任务在下个时种周期就开始的重映射算法取代了栈保存方法。在这个情境中，任务上下文切换非常快，在1到3机器时种之间（没有找到自由事件的查找操作）。通过展开测试，我们可以观察到翻倍FPGA芯片相关资源的效果。还有，使用软件实现的微处理器操作系统，比如uC/OS-II, KeilRTX或FreeRTOS进行了对比。这个实验性项目可以被用于测试为了硬件RTOS架构开发的实际应用，下一步是直接在ASIC（特殊应用集成电路）中实现这个概念。

未来研究方向将继续在RTOS的硬件实现相关工作上，将资源翻倍架构和它的硬件调度器定义模块纳入考虑之内。

# 致谢

。。。
